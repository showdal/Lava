day15

Object 클래스

	2. toString()
	 - 자바는 주소를 내부적으로 사용하지만 외부로 노출하지 않는다.
	   "클래스이름@해시코드값"
	   
	참고]
		해쉬코드
		- 자바는 해쉬테이블을 이용해 주소를 관리하는데
		  해쉬코드값은 주소를 관리하는 해쉬테이블의 코드값이 된다.
	
	문제]
		주소를 출력하면
		Object obj = new Object();
		obj에는 Object의 객체의 주소가 기억될 거싱고
		System.out.println(obj);
		출력을 하게되면 toString()이 자동 호출되게 된다.
		
	결론]
		toString()는 주소를 출력할  때 자동 호출되어서
		출력할 내용을 만들어주는 함수이다.
		
		만든 클래스를 출력할 때 오버라이드해서 사용하면 된다.
		
	참고]
		public void toString(String str){ //오버로드
			System.out.println(str)
		}
	
	3. clone()
		==> 자기 자신을 깊은 복사해주는 함수
			
			주의 ]
				이 함수는 접근 지정자가 protected 이므로
				상속받은 클래스나 같은 패키지의 클래스에서만 사용할 수 있다.
				
	4. hashCode()
		==> 자바는 주소를 노출하지 않기 위해서
			해쉬테이블을 이용해서 주소를 관리한다.
			그 해쉬테이블에 주소를 관리하는 코드값을 알려주는 함수
			
----------------------------------------------------------------------------
String 클래스와 StringBuffer 클래스의 차이점

	String 클래스는 문자열을 변경하게 되면 매번 Heap 영역에 객체를 생성하므로
	메모리가 낭비된다.
	문자열 수정이 많은 경우 StringBuffer 혹은 StringBulider를 사용한다.
	수정이 완료되면 반드시 String 타입으로 변경시켜 준다.
	=> 자바에서 사용하는 함수들의 매개변수는 대부분 String 타입의 데이터를 요구한다.
	toString() => Object 클래스의 toString() 함수를 오버라이딩 해놓은 함수이다.
	
----------------------------------------------------------------------------
숙제]
	String, StringBuffer, StringBuilder 소속의 함수를 각 10개이상 조사하고
	예
	
-----------------------------------------------------------------------------	

Math
  - 주로 수학적인 기능을 하는 함수로 구성된 클래스
  	모든 함수가 static이므로 new 시킬 필요가 없으며
  	new 시킬 수 없다.
	
----------------------------------------------------------------------------

래퍼 클래스 (Wrapper Class)
  -	주소(래퍼런스 변수)는 사용하는 곳에 기본데이터 타입을 사용할 수 없다.
	
	int를 인스턴스(주소)로 사용할 수 있게 만든 클래스
	
	참고]
		자바는 Object를 중심으로 계층 구조화해서 클래스를 이용하도록 하는
		객체지향 언어이다.
		
		기본데이터 타입(Value Type)은 객체지향 원리를 사용하지 않는다.
		다형성 구현에 문제가 생긴다.
	
	예]
		void abc(Object o){
		}	
		=> 이 함수는 모든 내용을 처리하도록 만든 함수이나
		   기본데이터 타입은 사용할 수 없다.

	종류]
		Boolean, Character, Byte, Short, Integer, Long, Float, Double
		
	참고]
		Boxing : 기본데이터 타입을 객체 타입으로 변환하는 것
		Unboxing : 객체타입을 기본데이터 타입으로 변환하는 것
		
		Wrapper Class : Boxing & Unboxing을 해주기 위한 클래스
		
		자바 1.4 이후 자동으로 Boxing과 Unboxing을 처리해준다.
		
	결론]
		자바는 내부적으로 모든 정보를 주소(레퍼런스)로 통일해서 사용 가능하다.
			
------------------------------------------------------------------------------		
		
java.util 패키지 소속의 유용한 클래스

	1. Objects
	   - 이 클래스는 static 함수로만 구성되어 있는 클래스
		 
		 예]
		 	isNull(Object o)
		 	- 객체에 내용이 있는지 확인하는 함수
		 	  (new 시킨 결과가 있는지 확인하는 함수)
			
			Object obj;
			
			try{
				xxx
				obj = new obj
				xxx
			} catch(Exception e){}			
		
		*****
		참고]
			null : 주소 변수에 주소가 없는 상태
				   찾아갈 대상이 없어 사용할 준비가 되어 있지 않다.
				   
-----------------------------------------------------------------------------

Random Class
  - 난수를 발생하는 클래스
	Math.random() 보다 다양한 형태의 난수를 발생시킬 수 있다.
	
	참고]
		seed : 컴퓨터에서 난수를 발생하는 것은
			   실제 난수가 발생하는 것은 아니다.
			   컴퓨터 내부에 난수 테이블이 존재하고 그 데이터를 순차적으로
			   꺼내 사용한다.
			   
			   난수테이블에서 난수를 꺼내는 위치를 seed라고 한다.
			   
--------------------------------------------------------------------------------

Arrays 클래스
  - static 함수로만 구성된 클래스
	배열을 처리할 때 필요한 유틸리티적인 함수들로 구성된 클래스
		   
	예]
		sort()
		- 배열에 있는 데이터를 정렬하는 기능을 가진 함수
		  
--------------------------------------------------------------------------------

정규식 검사
  - 주어진 문자열이 특정한 규칙에 맞는지 확인하는 기능
  
  예]
  	주민등록번호 6자리-7자리의 숫자로 구성되어 있는지
	아이디의 조합이 숫자와 대소문자인지?
	
	
	사용하는 클래스
		
		java.util.regex.Pattern
		- 정규식 검사에 사용할 정규식 문법(패턴)을 지정할 클래스
		
		java.util.regex.Matcher
		- 정규식 검사를 실제로 실행할 클래스
	
	
	참고]
		
		1. c[a-z]*
			글자를 특정위치에 기술하면 반드시 그 위치에 해당하는 글자가 와야 한다.
			[] 안에 기록하면 그 중 하나가 와야한다.
			* 바로 앞에 지정한 글자가 0개이상 올 수 있다.
			=> c로 시작하는 소문자 문자열
		
		2. c[a-z]
			c로 시작하고 다음 글자는 반드시 알파벳 소문자여야 한다.
			
		3. c[a-zA-Z]
			c로 시작하고 다음 글자는 알파벳이 와야 한다.
		
		4. c[a-zA-Z0-9]
			3번 + 숫자
			이 경우는 줄여서 c\w로 사용할 수 있다.
		
		5. .*
			.은 모든 문자(알파벳과 한글)를 의미
		
		6. c.
			c로 시작하고 그 다음 문자는 아무 문자 한 개가 와야 한다.
		
		7. c.*
			c로 시작하는 모든 문자가 0개 이상 오면 된다.
		
		8. c\.
			\. 은 .문자만 와야한다.
		
		9. c\d
			\d는 숫자 문자를 의미
			c로 시작하고 그 다음은 숫자가 온다.
			c[0-9]
		
	참고]
		이스케이프 문자 : 
		자바에서 문자열 데이터에 큰 따옴표를 포함하고 싶을 경우
		"가나다"라마"바사" => "가나다\"라마\"바사"
		표현하고 싶은 기호 앞에 역슬래시(\)를 붙여 문자열에 포함시키는 방법
			
				
		10. c.*t
			c로 시작하고 t로 끝나며 모든 문자가 올 수 있고 글자수는 상관 없다.
		
		11. [b|c].*
			b나 c로 시작하고 그 이후 모든 문자가 올 수 있고 글자수는 상관 없다.
			[b|c] => [b-c] => [bc]
		
		12. [^b|c]
			^는 NOT을 의미
			b 또는 c가 아닌 문자
		
		13. .*a.*
			a라는 문자가 포함된 문자열
		
		14. .*a.+
			* : 0개 이상
			+ : 1개 이상
		
		15. [b|c].{2}
			{}안의 숫자는 글자수를 의미
			b또는 c로 시작하는 3자리 문자열
			
		16. .{2, 3}
			{}안의 ,는 OR 을 의미
			2자리 혹은 3자리 수의 모든 문자열

	// 이 부분은 자바스크립트 문법		
			17. ^c
				==> 문자열의 첫글자는 반드시 c로 시작해야 한다.
				
			18. c$	==> "ㄴㅇ라ㅓ메ㅐㄹㅇㄴ;ㅁㄹccc"
				==> 문자열의 마지막 글자는 반드시 c 로 끝나야 한다.
				
-------------------------------------------------------------------------------

Scanner Class
  - 외부장치를 이용해 데이터를 받기위한 클래스
  
	참고]
		자바는 IO 개념을 이용해 외부장치와 연결한다.
		자바 1.5버전부터 만들어진 기능
		
	생성자 함수		
	- 외부장치인 File이나 IO인 Stream을 넣어달라고 하고 있다.
	
	참고]
		System.in
			내부적으로 키보드와 연결한 스트림으로 만들어 놓은 것
			
			Scanner sc = new Scanner(System.in);
			=> 키보드를 통해 입력받는 Scanner	
			
----------------------------------------------------------------------------------------------------

StringTokenizer

	==> 하나의 문자열을 원하는 문자를 기준으로 나누는 기능을 가진 클래스
		
		사용이유 ]
			네트워크등을 이용하면
			여러개의 데이터가 한번에 들어올 수 있다.
			
		예 ]
			카톡을 하면
			카톡을 보낸사람, 보낸시간, 내용,....등이
			하나의 문자열로 구성되어서 한번에 들어온다.
			==> 이런 경우 각각의 데이터를 분리해서 처리해야할 것이다.
				보낸사람@보낸시간@내용
				
		생성방법 ]
			
			1. StringTokenizer(String str)
				==> 문자열을 공백을 기준으로 나누는 기능
			
			2. StringTokenizer(String str, String delim)
				==> 문자열을 지정한 문자(String delim)를 기준으로 나누는 기능
				
			3. StringTokenizer(String str, String delim, boolean returnDelims)
				==> 2 + 구분문자도 하나의 문자로 처리한다.
				
		참고 ]
			분리된 결과는 임시 버퍼에 기억이 되어있다.
			***
			따라서 이것은 특징이 한번 사용하면 버퍼에서 그순간 지워버린다.
			따라서 한번 사용하면 더이상 사용할 수 없게 되고
			***
			반드시 순서대로만 꺼내야 한다.
			
		주요함수 ]
			
			countTokens()
				==> 문자열을 나눈 결과 수를 반환해주는 함수
				
			hasMoreElements() / hasMoreTokens()
				==> 임시버퍼에 내용이 남아있는지 여부를 묻는 함수
				
			nextElement() / nextToken()
				==> 데이터를 꺼내는 함수
			
-------------------------------------------------------------------------------------------------

BigDecimal 
	==> 정수로 표현할 수 없는 숫자를 사용하기 위한 클래스
		
		주로 데이터베이스와 연동할 때
		오라클의 데이터는 number(숫자)
			이 숫자는 38자리까지 사용할 수 있다.
		이런 데이터는 자바에서는 처리할 수 없으므로
		이런 유형의 데이터를 처리하기 위해서 만들어진 클래스이다.
		
		예 ]
			
			BigDecimal big = new BigDecimal("1234567890123456789012345678901234567");
			
----------------------------------------------------------------------------------------------------
			
Date 클래스

	==> 날짜와 시간을 관리하는 클래스
		
		생성자 함수 ]
			
			Date()
				==> 현재 시스템의 날짜와 시간을 이용해서 관리
				
			나머지 생성자
				==> 지정한 날짜와 시간을 이용해서 관리
				
		참고 ]
			이 클래스는 Calendar 클래스가 버젼업 버젼이므로
			자바는 Calendar 클래스 사용을 권장하고 있다.
			하지만 아직도 Date 클래스를 사용해야 하는 함수가 존재한다.
			따라서 알고는 있어야 한다.
				 	
---------------------------------------------------------------------------------------------------

Calendar Class
	==> Date 클래스를 버젼업 시켜놓은 클래스
		
		생성방법 ]
			
			**
			이 클래스는 생성자 함수를 감춰놓은 경우에 해당하므로
			스스로 new 시켜서 객체를 만들수는 없고
			함수중 속성이 static 이면서 반환값이 Calendar 인 함수를 찾아서 객체를 사용해야 한다.
			
			Calendar car = new Calendar(); ==> X
			
			Calendar car = Calendar.getInstance(); ==> O
			
		주요함수 ]
			
			get(int field)
				==> 필요한 정보를 알려주는 함수
					이 함수는 (int field)에 알고자하는 내용을 알려주면
					그 값에 대해서 알려주는 함수이다.
					
					중요 ]
						
						Calendar 클래스는
						각각의 변수가 무엇을 알기 위한 변수인지를 공부해 놓는 것이 좋다.
						Field Summery를 보세요...
						
			getTime()
				==> Calendar 클래스를 Date 클래스로 변환하는 함수
					
					실무에서는 Calendar 클래스를 이용해서 작업을 하다가
					필요하면 Date클래스로 변환해서 사용할 필요가 있다.
					
					예 ]
						
						Calendar car = Calendar.getInstance();
						.....
						Date d = car.getTime();
						
				참고 ]
					자바 API의 함수 이용 방법
				 		
				 		자바의 함수를 보면 문자열로 의미하는 내용을
				 		int로 입력해 달라는 함수가 많이 존재한다.
				 		이런 경우는 99% 가 자기자신이 가진 그 문자열을 의미하는 숫자를
				 		담아 놓은 변수를 가지고 있다.
				 		그 변수를 이용해서 처리하면 된다.
				 		
				 		예]
				 			showConfirmDialog(Component parentComponent, 
				 								Object message, String title, int optionType)
				 			
				 			==> int optionType은 이미 JOptionPane에서 정의 해놓은 상수가 존재하고
				 				그 상수를 입력해주면 된다.
				 	
				 	
				 	
				 	
				 	
				 	
				 	
				 	
				 	
				 	
				 	