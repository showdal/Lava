day10

	객체지향언어
	- 클래스를 이용해서 프로그램을 제작하는 언어
	
	클래스
	- 프로그램의 기본 단위, 멤버 = 변수, 함수
	
	String
	- 문자열
	Socket
	- 네트워크
	Collection
	- AraraysList, HashMap, HashSet,... => 많은 양의 데이터를 보관, 관리
	
	
	클래스 만드는 방법
	
	[접근지정자][속성] class 클래스이름 {
		변수선언;
		...
		함수선언(){
			함수내용
		}
		...
	}
	
	
	******
	그런데 클래스는 단지 설계도에 불과하다.
	즉, 클래스만 가지고 있다고해서 이것이 실행되는 것은 아니다.
	반드시 클래스가 실행 가능한 물건으로 탄생이 되어야 한다.
	
	이처럼 클래스를 실행 가능한 물건으로 만드는 것
		"Object"
	다 라고 한다.
	
	결론적으로
	객체지향언어는
	클래스를 기반으로 만들어진 Object에 의해서 만들어지는 프로그램....
	
	우리는 이미 부품 설계도는 많이 충분히 엄청나게 준비가 되어있다.
	이것들을 적절한 위치에 조립해서
	원하는 프로그램을 만들어나가는 기법이
	객체지향프로그램이다...
	라고 이해하면 될 것이다.
	
	
	
	객체(Object)
	- JVM이 만든다. 따라서 개발자는 필요한 부품을 만들어달라고 명령만 내리면 된다.
	
	***
	객체 = 레퍼런스 변수 + 인스턴스
	
	형식]
		클래스이름 변수이름;
		변수이름 = new 클래스이름();
			
	예]
		Test t;
		t = new Test();
		
		t : 레퍼런스 변수, Heap Type은 Test
		
		
		Heap에 만들어진 클래스를 Instance라 부르고
		Instance의 주소를 기억하는 변수를 Reference라 부른다.
			
			
	
	객체 사용방법
	- 데이터를 기억하거나 함수를 이용
	
	
	주소.변수;
	주소.함수();	<= 소속을 밝힐 때 . 사용
	
	
	예]
		class Test {
			int a;
			void abc(){}
		}
		
		Test t = new Test();
		
		t.a;
		t.abc();
	
	참고]
		클래스 안에 오브젝트의 개수는 상관 ㄴㄴ
		
		Test t = new Test();	<= new 명령으로 Heap 영역에 Instance를 만들어 변수에 기억
		Test tt = new Test();
		
		
		주소를 사용하므로
		각각의 오브젝트는 독립적 실행 가능
		=> day10.Test02 참고
		
	
	참고]
		지역변수
		- 해당 블럭내에서만 사용. 해당 블럭을 벗어나면 사라짐
		  실행되는 순강 변수가 생성됨.
		
		전역변수	
		- 모든 시역에서 사용. 클래스 안에서 생성된 멤버 변수
		  new 시키면 Heap영역에 생성되므로 계속 사용 가능
	
		  new 에서 생성 -> 프로그램 종료 시 소멸
	
	
	
	객체의 배열
	- 하나의 클래스에 여러개의 오브젝트를 배열로 관리
	
	
	형식]
		클래스이름[] 변수 = new 클래스이름[개수]
		
	예 ]
		Test[] t = new Test[5];
		==> Test클래스를 배열로 관리할 주소를 기억하는 변수를 만들고
			아직 실질적으로 인스턴스(객체)는 만들지 않았다.
		
		// 각 방에 인스턴스를 만들어 준다.
		t[0] = new Test();
		t[1] = new Test();
		t[2] = new Test();
		t[3] = new Test();
		t[4] = new Test();		
		
	사용]
		배열변수[위치].멤버	
		
	참고]
		클래스는 변수와 함수로 구성이 되어있고
		이 두개를 멤버라고 부른다.
		
		특별히 멤버중 변수를 멤버변수라 부르고 영어로 Field 라 칭한다.
		멤버함수는 클래스안에 만들어진 함수를 의미한다.		
	
	
	

함수의 오버로딩(Overloading : 함수의 중첩)
==> 원칙적으로 같은 클래스내에서는 함수의 이름은 모두 달라야 한다.
	같은 클래스 안에서 같은 이름의 함수가 존재하면 에러가 발생한다.
	
	이러다보니 가독성에 있어서 문제가 발생된다.
	즉, 함수의 가독성이란?
	함수의 이름만 보고도 그 함수가 어떤 역할을 하는지 알아야 하는데
	함수의 이름을 모두 다르게 작성을 한다면
	가독성에 문제 발생할 수 있다.
	
	이 문제를 해결하기 위해서 도입된 문법이
	함수의 오버로딩(Overloading)이다.
	
	
	*****
	오버로딩이란?
		같은 클래스안에 같은 이름의 함수를 만들 수 있다.
		단, 다음 조건은 반드시 지켜야 한다.
		
		규칙 ]
			0. 같은 이름의 함수가 클래스 내에 존재해야 한다.
			1. 함수의 이름은 같아야 한다.
			2. 매개변수 리스트는 달라야 한다.
				==> 개수, 순서, 타입 중 하나 이상이 달라야 한다.
			3. 반환값 유형과는 전혀 상관이 없다.
			
			
		예 ]
			
			void abc(){
			}
			
			void abc(int a){
			}							==> O
			
			int abc(){
			}							==> X : 반환값과는 상관이 없다.
			
			void abc1(){}				==> O 오버로딩이 아니다.
			
			int abc(float f){}			==> O
			
			int abc(int a, int b){}		==> O
		
		
			
	결론] 
		함수를 호출할 때 정확한 함수를 선택할 수 있도록 해야 한다.
		
		
	사용법 ]
		다른 사람이 만든 클래스에도 오버로딩이 구현된 함수를 볼 수 있다.
		
		이들 함수를 사용하는 방법
		
		원하는 기능을 하는 함수가 요구하는 데이터를
		형태와 순서에 맞게 정확하게 입력해 줘야 한다.
		
		참고 ]
			형태가 맞지 않더라도 사용할 수 있는 경우가 있는데
			자동형변환이 되는 경우는 사용 할 수 있다.
			
			예]
				
				void abc(double d){}
				
				==>
				abc(3.);	==> O
				abc(3f);	==> O
				abc('A');	==> O
				abc(10);	==> O
				
	
	
	향상된 for 명령
	
	for(데이터타입 변수이름 : 배열변수){}			
				
	
	가변인자
	- 함수의 매개변수와 동일한 개수, 형태, 순서를 이용해서
	  함수를 호출해야 한다.
	  
	  void abc(int a){} => abc(10);
	  	
	  void abc(int a){} => abc(10,20);
	  

	
	사람의 이름을 입력해주면 그 사람들의 인원수를 카운트 해주는 함수
	
	public int getCnt(String[] name){
		return name.length;
	}

-------------------------------------------------------------------------

	위의 경우는 배열을 별도로 준비해서 입력해줘야 할 것이다.
	만약 배열을 준비할 수 없다면???
	
	
	***
	데이터의 개수를 지정할 수 없는 경우
	매개변수로 사용할 수있는 방법이 가변인수
	
	데이터의 개수와 상관없이 모든 데이터를 다 받을 수 있다.
	
	형식]
		[접근지정자][속성] 반환값타입 함수이름(데이터타입...변수이름){}
	
	예]
		void abc(int...num){
			=> 데이터의 개수와 상관없이 입력 가능
		}
	
	주의]
		가변인수 변수는 자동 배열 변수가 된다.
		따라서 사용할 때는 배열처럼 사용해야 된다.
		
	**
	주의]
		가변인수 앞에는 다른 매개변수가 와도 상관이 없다.
		하지만 가변인수 뒤에는 다른 매개변수가 오면 절대로 안된다.
						
		
	
	  