day11

생성자 함수(Constructor)
 - 클래스를 사용하기 위해 new 시키는 순간 자동 실행되는 함수
   멤버 초기화
   
   클래스를 new한다는 것은 오브젝트(객체)로 만들어 실행한다는 개념
   오브젝트를 만드는 순간에 무언가를 실행
   물건을 만들 때 필요한 조치를 해야한다.
   => 객체를 실제로 만들기 위한 함수
   
   클래스는 한가지 목적을 위한 프로그램의 단위
   변수, 함수로 구성
   목적을 위해 기본적으로 해줘야하는 조치가 있다.
   
   예]
	  String
	  - 문자열 관리하기 위한 클래스
	  - String()
	  	String(문자열);
	  
	  FileOutputStream
	  - 파일 내용을 기록하기 위한 클래스
   	  - 파일을 사용할 수 있도록 열어둬야 한다.
   	  
   	  Socket
   	  - 네트워크를 구성하기 위한 클래스
   	  - 상대방과 접속이 이뤄져야 함.
   
   
   각각의 클래스가 객체가 되는 순간 필요한 함수를
   "생성자 함수(Constructor)"라 한다
   클래스의 목적에 따라 클래스가 할 기본적인 일을 처리하기 위해
   
   
   방법]
		1. 함수의 이름은 클래스와 동일(대소문자 구분)
		2. 반환값 ㄴㄴ
		3. 매개변수 가능
		
   예]
		class Test{
			Test(){ //생성자함수
			}
			Test(int a){ // 매개변수가 있는 함수
			}
			void Test(){} // 반환값을 가지면 일반함수가 됨.
			}
		}
   
   참고]
		생성자함수는 오버로딩이 가능하다.
   		=> new 시킬 때 호출하는 함수를 정확히 지정한다.
   
   예]
		class Test{
			Test(){}
			Test(int a){}
		}		
		
		//객체 생성		
		new Test();
		new Test(10);
	
	
   참고]
		기본 생성자함수(Default Constructor)
		- 매개변수가 없는 생성자함수
		
		*****
		생성자함수가 없어도 new 명령으로 객체를 만들 수 있다.
		JVM(자바가상머신)이 기본 생성자를 내부적으로 만들어 호출한다.
		자바는 new 시킬 때 마다 생성자함수를 이용하게 된다.
		
		*****
		생성자함수가 1개라도 정의되면 JVM이 기본 생성자를 만들지 않는다.
		
		
   방법]
		생성자함수가 요구하는 매개변수를 보면
		클래스를 객체로 생성할 수 있는 방법을 알 수 있다.
	
   참고]
		클래스를 만들 때 다양한 생성자함수를 이용하는 것이 좋다.
   
   
   **********
   참고]
		this()
		- 생성자함수는 원칙적으로 직접 호출 불가
		  
		  현재 생성자를 실행하는 도중
		  다른 생성자를 강제로 호출하는 유일한 방법
		  
		***
		규칙]
			1. 생성자 안에서만 사용
			   일반함수 안에서는 사용 불가
			2. 생성자 함수의 첫 줄, 첫 문장으로 사용
		
		
		=> 클래스는 한 가지 목적을 가진 프로그램의 집합
		   따라서 생성자함수가 하는 기능이 거의 비슷하므로
		   중복되는 것을 방지해 생성자끼리 이용하는 기법
		
--------------------------------------------------------------------------

this
 - 현재 실행 중인 오브젝트의 주소를 기억하는 약속된 변수
 
   JVM이 클래스를 처리하기 위해 사용하는 변수
   			
	규칙]
		1. 멤버(함수,변수)는 사용할 때 앞에 주소가 필요
		   new 시킨 후 그 주소를 기억하여 이용
		2. 주소가 없으면 JVM이 자동으로 this를 붙여준다.
		3. 멤버 함수를 호출할 때 주소를 기억하여
		   this 변수를 준비한 후
		   함수를 호출할 때 알려준 주소를 기억하게 된다.
	
	참고]
		지역변수와 멤버변수 이름이 동일한 경우
		지역변수를 우선 사용하게 된다.
		
		강제로 this를 써서 멤버변수를 사용할 수 있다.
		
=========================================================================
static 속성
 - static 영역 안의 함수나 변수에 붙여주는 속성
	
	참고]
		클래스, 함수, 변수를 만들 때 속성을 지정할 수 있다.
	
	예]
		클래스
		[접근지정자][속성] class 클래스이름{}
		
		함수
		[접근지정자][속성] 반환값타입 함수이름(매개변수리스트){}
		
		변수
		[접근지정자][속성] 데이터타입 변수이름;
		
		
	특징]
		1. 프로그램이 실행되기 위해 JVM이 자동으로 생성한다.
		***
		2. 한번 생긴 변수나 함수는 다시 생기지 않는다.
		
	
	
	
	static 변수
	- static 영역에 만들어지는 변수
	
	[접근지정자][속성] 데이터타입 변수이름;
	
	특징]
		1. 여러 오브젝트가 사용하는 공동 변수
		   => 한 객체가 데이터를 바꾸면 다른 객체도 데이터가 바뀐다.
		  	  static 변수는 객체 멤버로 의미가 없고 객체없이 사용 가능하다.
		
		2. new 시키지 않아도 사용 가능 변수
		   => 이미 메모리에 올려져 있다.
		
	방법]
		클래스이름.변수이름		
		
		
		
		
	static 함수		
	- static 영역에 생기는 함수
	  객체없이 사용 가능
	  
	방법]
		클래스이름.함수이름();
	
	***
	특징]
		this를 사용할 수 없는 함수
	
	***	
	결론]	
		static 함수 안에서는 static 멤버만 사용 가능
		(메모리에 올려진 멤버는 모두 사용 가능)
		일반 함수 안에서는 일반 멤버와 static 멤버 모두 사용 가능
		
---------------------------------------------------------------------
맴버 변수의 초기화
- 멤버 변수는 Heap 영역에 생기므로 자동 초기화된다.
  가끔 변수에 기본값을 지정할 필요가 있다.		
		
	1. 명시적 초기화
		- 변수를 선언하면서 값을 입력하는 방법
	  	가장 먼저 실행되는 방법
		
		예]
			class Test{
				int no = 10;	==> 명시적 초기화
			}
			
	2. 초기화 블럭을 이용한 초기화
		- 이것은 인스턴스 변수(멤버변수)에 대해서만 가능한 방법
		  두번째로 실행되는 방법
			
		형식]
			{
				이 안에서 데이터를 변수에 입력
			}
			
		예]
			class Test {
				int no ;
				
				{
					no = 10;
				}
			}		
		
	3. static 블럭을 이용한 초기화
		- 2번과 반대로 static 변수에 한해서만 가능한 방법
		  두번째로 실행되는 방법
		
		형식]
			static {
				데이터 입력
			}
			
		예]
			class Test {
			static int no;
				
				static {
					no = 10;
				}
			}
			
	4. 생성자 함수를 이용한 초기화	
		- 가장 마지막에 실행되는 방법
		
		예]	
			class Test {
				int no ;
				
				public Test(){
					this.no = 10;
				}
			}
			
===============================================================
상 속
	==> 객체지향언어의 핵심
		이미 만들어진 클래스의 기능을 그대로 부여받아서
		(함수, 변수를 그대로 복사 받아서)
		새로운 클래스를 만드는 방법
		
		이 개념이 나타나게된 이유는???
		소프트웨어의 개발 속도를 빠르게 하기 위한 방법의 한가지이다.
		
		즉, 상속은 객체지향에서 매우 중요한 역할을 하는 것으로...
		
		객체 지향 언어는 부품단위(클래스)로 프로그램을 만든 후
		그 부품을 조립해서 원하는 결과를 얻어내는 언어이다.
		
		==>
		어디서 부품을 구했는데
		그 기능이 사용자 마음에 꼭 맞지 않을 수 있다.
		그러면 처음부터 다시 만들어야 하는가???
		라는 문제에 도달한다.
		이 문제를 해결하기 위해서 만든 방법이 상속이다.
		
		상속은 자신이 만들고자 하는 부품과 가장 유사한 부품을 가지고 와서
		일단 그 기능을 복사한 후
			1. 없는 기능만 더 붙이고
			2. 있는 기능에서 바꿀 내용만 바꾸자.
			
		*	
		형식 ]
			
			[접근지정자]	[속성]		class	클래스이름 extends 상속받을클래스이름 {
			
			}
		
		***
		참고 ]
			자바에서는 상속은 오직 단일 상속만 가능하다.
			
			예 ]
				class Test{}
				
				class Test1{}
				
				class Exec 	extends Test, Test1 {} ==> X : 단일상속만 가능하다.	
				
				
	용어정리 ]
		
		상속을 해준 클래스	- super Class, 상위 클래스, 부모클래스
		상속을 받은 클래스	- sub Class, 하위 클래스, 자식클래스
		
		is a	- 상속 관계에 있는 클래스를 부르는 용어 
					(상속 관계에 있다 라는 표현)
					
					class Father{}
					
					class Son extends Father{}
					
					Son is Father의 관계가 성립한다.
					
		
		has a	- 어떤 클래스 안에 다른 클래스를 멤버로 가지고 있는 상태
			
					class Father{}
					
					class Son {
						Father f = new Father();
					}
					
					Son has a Father 가 성립된다.
					
============================================================================
상속 관계에 있는 경우 생성자의 역할
	
	하위 클래스가 생성되는 순간
	상위 클래스가 자동 생성이 된다. ====> 상위 클래스의 생성자 함수가 자동호출된다.
	
	==> 생성되는 순간 생성자 함수가 호출되므로
		결국
			하위 클래스를 생성하면
			상위 클래스의 생성자 함수도 실행된다.
			
	결국 상위 클래스의 생성자 함수는 자동으로 호출되는 개념이다.
	자동 호출 되는 경우에는 무조건 기본 생성자만 이용하게 된다.
	
	***
	참고 ]
		
		super()
			==> 상위 클래스의 특별한 생성자를 강제로 호출하는 기능을 가진 명령...
			
		특징 ]
			1. 반드시 생성자 함수 안에서만 사용할 수 있다.
			2. 반드시 첫줄 첫문자으로만 사용 해야 한다.
			
			
		



